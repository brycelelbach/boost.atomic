<?xml version="1.0" standalone="yes"?>
<library-reference><header name="boost/libs/atomic/doc/atomic.hpp"><namespace name="boost"><class name="atomic"><template>
      <template-type-parameter name="Type"/>
    </template><purpose>Atomic datatype. </purpose><description><para>An atomic variable. Provides methods to modify this variable atomically. Valid template parameters are:</para><para><itemizedlist>
<listitem><para>integral data types (char, short, int, ...)</para></listitem><listitem><para>pointer data types</para></listitem><listitem><para>any other data type that has a non-throwing default constructor and that can be copied via <computeroutput>memcpy</computeroutput></para></listitem></itemizedlist>
</para><para>Unless specified otherwise, any memory ordering constraint can be used with any of the atomic operations. </para></description><method-group name="public member functions"><method name="load" cv="const"><type>Type</type><parameter name="order"><paramtype>memory_order</paramtype><default>memory_order_seq_cst</default><description><para>Memory ordering constraint, see memory_order </para></description></parameter><purpose>Read the current value of the atomic variable. </purpose><description><para>

Valid memory ordering constraints are:<itemizedlist>
<listitem><para><computeroutput>memory_order_relaxed</computeroutput> </para></listitem><listitem><para><computeroutput>memory_order_consume</computeroutput> </para></listitem><listitem><para><computeroutput>memory_order_acquire</computeroutput> </para></listitem><listitem><para><computeroutput>memory_order_seq_cst</computeroutput> </para></listitem></itemizedlist>
</para></description><returns><para>Current value of the variable</para></returns></method><method name="store" cv=""><type>void</type><parameter name="value"><paramtype>Type</paramtype><description><para>New value </para></description></parameter><parameter name="order"><paramtype>memory_order</paramtype><default>memory_order_seq_cst</default><description><para>Memory ordering constraint, see memory_order</para></description></parameter><purpose>Write new value to atomic variable. </purpose><description><para>
Valid memory ordering constraints are:<itemizedlist>
<listitem><para><computeroutput>memory_order_relaxed</computeroutput> </para></listitem><listitem><para><computeroutput>memory_order_release</computeroutput> </para></listitem><listitem><para><computeroutput>memory_order_seq_cst</computeroutput> </para></listitem></itemizedlist>
</para></description></method><method name="compare_exchange_weak" cv=""><type>bool</type><parameter name="expected"><paramtype>Type &amp;</paramtype><description><para>Expected old value </para></description></parameter><parameter name="desired"><paramtype>Type</paramtype><description><para>Desired new value </para></description></parameter><parameter name="order"><paramtype>memory_order</paramtype><default>memory_order_seq_cst</default><description><para>Memory ordering constraint, see memory_order </para></description></parameter><purpose>Atomically compare and exchange variable. </purpose><description><para>

Atomically performs the following operation</para><para><programlisting>                if (variable==expected) {
                        variable=desired;
                        return true;
                } else {
                        expected=variable;
                        return false;
                }
</programlisting></para><para>This operation may fail "spuriously", i.e. the state of the variable is unchanged even though the expected value was found (this is the case on architectures using "load-linked"/"store conditional" to implement the operation).</para><para>The established memory order will be <computeroutput>order</computeroutput> if the operation is successful. If the operation is unsuccesful, the memory order will be</para><para><itemizedlist>
<listitem><para><computeroutput>memory_order_relaxed</computeroutput> if <computeroutput>order</computeroutput> is <computeroutput>memory_order_acquire</computeroutput> , <computeroutput>memory_order_relaxed</computeroutput> or <computeroutput>memory_order_consume</computeroutput> </para></listitem><listitem><para><computeroutput>memory_order_release</computeroutput> if <computeroutput>order</computeroutput> is <computeroutput>memory_order_acq_release</computeroutput> or <computeroutput>memory_order_release</computeroutput> </para></listitem><listitem><para><computeroutput>memory_order_seq_cst</computeroutput> if <computeroutput>order</computeroutput> is <computeroutput>memory_order_seq_cst</computeroutput> </para></listitem></itemizedlist>
</para></description><returns><para><computeroutput>true</computeroutput> if value was changed</para></returns></method><method name="compare_exchange_weak" cv=""><type>bool</type><parameter name="expected"><paramtype>Type &amp;</paramtype><description><para>Expected old value </para></description></parameter><parameter name="desired"><paramtype>Type</paramtype><description><para>Desired new value </para></description></parameter><parameter name="success_order"><paramtype>memory_order</paramtype><description><para>Memory ordering constraint if operation is successful </para></description></parameter><parameter name="failure_order"><paramtype>memory_order</paramtype><description><para>Memory ordering constraint if operation is unsuccesful </para></description></parameter><purpose>Atomically compare and exchange variable. </purpose><description><para>

Atomically performs the following operation</para><para><programlisting>                if (variable==expected) {
                        variable=desired;
                        return true;
                } else {
                        expected=variable;
                        return false;
                }
</programlisting></para><para>This operation may fail "spuriously", i.e. the state of the variable is unchanged even though the expected value was found (this is the case on architectures using "load-linked"/"store conditional" to implement the operation).</para><para>The constraint imposed by <computeroutput>success_order</computeroutput> may not be weaker than the constraint imposed by <computeroutput>failure_order</computeroutput>. </para></description><returns><para><computeroutput>true</computeroutput> if value was changed</para></returns></method><method name="compare_exchange_strong" cv=""><type>bool</type><parameter name="expected"><paramtype>Type &amp;</paramtype><description><para>Expected old value </para></description></parameter><parameter name="desired"><paramtype>Type</paramtype><description><para>Desired new value </para></description></parameter><parameter name="order"><paramtype>memory_order</paramtype><default>memory_order_seq_cst</default><description><para>Memory ordering constraint, see memory_order </para></description></parameter><purpose>Atomically compare and exchange variable. </purpose><description><para>

Atomically performs the following operation</para><para><programlisting>                if (variable==expected) {
                        variable=desired;
                        return true;
                } else {
                        expected=variable;
                        return false;
                }
</programlisting></para><para>In contrast to compare_exchange_weak, this operation will never fail spuriously. Since compare-and-swap must generally be retried in a loop, implementors are advised to prefer compare_exchange_weak where feasible.</para><para>The established memory order will be <computeroutput>order</computeroutput> if the operation is successful. If the operation is unsuccesful, the memory order will be</para><para><itemizedlist>
<listitem><para><computeroutput>memory_order_relaxed</computeroutput> if <computeroutput>order</computeroutput> is <computeroutput>memory_order_acquire</computeroutput> , <computeroutput>memory_order_relaxed</computeroutput> or <computeroutput>memory_order_consume</computeroutput> </para></listitem><listitem><para><computeroutput>memory_order_release</computeroutput> if <computeroutput>order</computeroutput> is <computeroutput>memory_order_acq_release</computeroutput> or <computeroutput>memory_order_release</computeroutput> </para></listitem><listitem><para><computeroutput>memory_order_seq_cst</computeroutput> if <computeroutput>order</computeroutput> is <computeroutput>memory_order_seq_cst</computeroutput> </para></listitem></itemizedlist>
</para></description><returns><para><computeroutput>true</computeroutput> if value was changed</para></returns></method><method name="compare_exchange_strong" cv=""><type>bool</type><parameter name="expected"><paramtype>Type &amp;</paramtype><description><para>Expected old value </para></description></parameter><parameter name="desired"><paramtype>Type</paramtype><description><para>Desired new value </para></description></parameter><parameter name="success_order"><paramtype>memory_order</paramtype><description><para>Memory ordering constraint if operation is successful </para></description></parameter><parameter name="failure_order"><paramtype>memory_order</paramtype><description><para>Memory ordering constraint if operation is unsuccesful </para></description></parameter><purpose>Atomically compare and exchange variable. </purpose><description><para>

Atomically performs the following operation</para><para><programlisting>                if (variable==expected) {
                        variable=desired;
                        return true;
                } else {
                        expected=variable;
                        return false;
                }
</programlisting></para><para>In contrast to compare_exchange_weak, this operation will never fail spuriously. Since compare-and-swap must generally be retried in a loop, implementors are advised to prefer compare_exchange_weak where feasible.</para><para>The constraint imposed by <computeroutput>success_order</computeroutput> may not be weaker than the constraint imposed by <computeroutput>failure_order</computeroutput>. </para></description><returns><para><computeroutput>true</computeroutput> if value was changed</para></returns></method><method name="exchange" cv=""><type>Type</type><parameter name="value"><paramtype>Type</paramtype><description><para>New value </para></description></parameter><parameter name="order"><paramtype>memory_order</paramtype><default>memory_order_seq_cst</default><description><para>Memory ordering constraint, see memory_order </para></description></parameter><purpose>Atomically exchange variable. </purpose><description><para>

Atomically exchanges the value of the variable with the new value and returns its old value. </para></description><returns><para>Old value of the variable</para></returns></method><method name="fetch_add" cv=""><type>Type</type><parameter name="operand"><paramtype>Type</paramtype><description><para>Operand </para></description></parameter><parameter name="order"><paramtype>memory_order</paramtype><default>memory_order_seq_cst</default><description><para>Memory ordering constraint, see memory_order </para></description></parameter><purpose>Atomically add and return old value. </purpose><description><para>

Atomically adds operand to the variable and returns its old value. </para></description><returns><para>Old value of the variable</para></returns></method><method name="fetch_sub" cv=""><type>Type</type><parameter name="operand"><paramtype>Type</paramtype><description><para>Operand </para></description></parameter><parameter name="order"><paramtype>memory_order</paramtype><default>memory_order_seq_cst</default><description><para>Memory ordering constraint, see memory_order </para></description></parameter><purpose>Atomically subtract and return old value. </purpose><description><para>

Atomically subtracts operand from the variable and returns its old value.</para><para>This method is available only if <computeroutput>Type</computeroutput> is an integral type or a non-void pointer type. If it is a pointer type, <computeroutput>operand</computeroutput> is of type <computeroutput>ptrdiff_t</computeroutput> and the operation is performed following the rules for pointer arithmetic in C++. </para></description><returns><para>Old value of the variable</para></returns></method><method name="fetch_and" cv=""><type>Type</type><parameter name="operand"><paramtype>Type</paramtype><description><para>Operand </para></description></parameter><parameter name="order"><paramtype>memory_order</paramtype><default>memory_order_seq_cst</default><description><para>Memory ordering constraint, see memory_order </para></description></parameter><purpose>Atomically perform bitwise "AND" and return old value. </purpose><description><para>

Atomically performs bitwise "AND" with the variable and returns its old value.</para><para>This method is available only if <computeroutput>Type</computeroutput> is an integral type or a non-void pointer type. If it is a pointer type, <computeroutput>operand</computeroutput> is of type <computeroutput>ptrdiff_t</computeroutput> and the operation is performed following the rules for pointer arithmetic in C++. </para></description><returns><para>Old value of the variable</para></returns></method><method name="fetch_or" cv=""><type>Type</type><parameter name="operand"><paramtype>Type</paramtype><description><para>Operand </para></description></parameter><parameter name="order"><paramtype>memory_order</paramtype><default>memory_order_seq_cst</default><description><para>Memory ordering constraint, see memory_order </para></description></parameter><purpose>Atomically perform bitwise "OR" and return old value. </purpose><description><para>

Atomically performs bitwise "OR" with the variable and returns its old value.</para><para>This method is available only if <computeroutput>Type</computeroutput> is an integral type. </para></description><returns><para>Old value of the variable</para></returns></method><method name="fetch_xor" cv=""><type>Type</type><parameter name="operand"><paramtype>Type</paramtype><description><para>Operand </para></description></parameter><parameter name="order"><paramtype>memory_order</paramtype><default>memory_order_seq_cst</default><description><para>Memory ordering constraint, see memory_order </para></description></parameter><purpose>Atomically perform bitwise "XOR" and return old value. </purpose><description><para>

Atomically performs bitwise "XOR" with the variable and returns its old value.</para><para>This method is available only if <computeroutput>Type</computeroutput> is an integral type. </para></description><returns><para>Old value of the variable</para></returns></method><method name="conversion-operator" cv="const"><type>Type</type><parameter name=""><paramtype>void</paramtype></parameter><purpose>Implicit load. </purpose><description><para>
The same as <computeroutput>load(memory_order_seq_cst)</computeroutput>. Avoid using the implicit conversion operator, use load with an explicit memory ordering constraint. </para></description><returns><para>Current value of the variable</para></returns></method><method name="operator&amp;=" cv=""><type>Type</type><parameter name="operand"><paramtype>Type</paramtype><description><para>Operand </para></description></parameter><purpose>Atomically perform bitwise "AND" and return new value. </purpose><description><para>

The same as <computeroutput>fetch_and(operand, memory_order_seq_cst)&amp;operand</computeroutput>. Avoid using the implicit bitwise "AND" operator, use fetch_and with an explicit memory ordering constraint. </para></description><returns><para>New value of the variable</para></returns></method><method name="operator|=" cv=""><type>Type</type><parameter name="operand"><paramtype>Type</paramtype><description><para>Operand </para></description></parameter><purpose>Atomically perform bitwise "OR" and return new value. </purpose><description><para>

The same as <computeroutput>fetch_or(operand, memory_order_seq_cst)|operand</computeroutput>. Avoid using the implicit bitwise "OR" operator, use fetch_or with an explicit memory ordering constraint.</para><para>This method is available only if <computeroutput>Type</computeroutput> is an integral type. </para></description><returns><para>New value of the variable</para></returns></method><method name="operator^=" cv=""><type>Type</type><parameter name="operand"><paramtype>Type</paramtype><description><para>Operand </para></description></parameter><purpose>Atomically perform bitwise "XOR" and return new value. </purpose><description><para>

The same as <computeroutput>fetch_xor(operand, memory_order_seq_cst)^operand</computeroutput>. Avoid using the implicit bitwise "XOR" operator, use fetch_xor with an explicit memory ordering constraint.</para><para>This method is available only if <computeroutput>Type</computeroutput> is an integral type. </para></description><returns><para>New value of the variable</para></returns></method><method name="operator+=" cv=""><type>Type</type><parameter name="operand"><paramtype>Type</paramtype><description><para>Operand </para></description></parameter><purpose>Atomically add and return new value. </purpose><description><para>

The same as <computeroutput>fetch_add(operand, memory_order_seq_cst)+operand</computeroutput>. Avoid using the implicit add operator, use fetch_add with an explicit memory ordering constraint.</para><para>This method is available only if <computeroutput>Type</computeroutput> is an integral type or a non-void pointer type. If it is a pointer type, <computeroutput>operand</computeroutput> is of type <computeroutput>ptrdiff_t</computeroutput> and the operation is performed following the rules for pointer arithmetic in C++. </para></description><returns><para>New value of the variable</para></returns></method><method name="operator-=" cv=""><type>Type</type><parameter name="operand"><paramtype>Type</paramtype><description><para>Operand </para></description></parameter><purpose>Atomically subtract and return new value. </purpose><description><para>

The same as <computeroutput>fetch_sub(operand, memory_order_seq_cst)-operand</computeroutput>. Avoid using the implicit subtract operator, use fetch_sub with an explicit memory ordering constraint.</para><para>This method is available only if <computeroutput>Type</computeroutput> is an integral type or a non-void pointer type. If it is a pointer type, <computeroutput>operand</computeroutput> is of type <computeroutput>ptrdiff_t</computeroutput> and the operation is performed following the rules for pointer arithmetic in C++. </para></description><returns><para>New value of the variable</para></returns></method><method name="operator++" cv=""><type>Type</type><parameter name=""><paramtype>void</paramtype></parameter><purpose>Atomically increment and return new value. </purpose><description><para>
The same as <computeroutput>fetch_add(1, memory_order_seq_cst)+1</computeroutput>. Avoid using the implicit increment operator, use fetch_add with an explicit memory ordering constraint.</para><para>This method is available only if <computeroutput>Type</computeroutput> is an integral type or a non-void pointer type. If it is a pointer type, the operation is performed following the rules for pointer arithmetic in C++. </para></description><returns><para>New value of the variable</para></returns></method><method name="operator++" cv=""><type>Type</type><parameter name=""><paramtype>int</paramtype></parameter><purpose>Atomically increment and return old value. </purpose><description><para>
The same as <computeroutput>fetch_add(1, memory_order_seq_cst)</computeroutput>. Avoid using the implicit increment operator, use fetch_add with an explicit memory ordering constraint.</para><para>This method is available only if <computeroutput>Type</computeroutput> is an integral type or a non-void pointer type. If it is a pointer type, the operation is performed following the rules for pointer arithmetic in C++. </para></description><returns><para>Old value of the variable</para></returns></method><method name="operator--" cv=""><type>Type</type><parameter name=""><paramtype>void</paramtype></parameter><purpose>Atomically subtract and return new value. </purpose><description><para>
The same as <computeroutput>fetch_sub(1, memory_order_seq_cst)-1</computeroutput>. Avoid using the implicit increment operator, use fetch_sub with an explicit memory ordering constraint.</para><para>This method is available only if <computeroutput>Type</computeroutput> is an integral type or a non-void pointer type. If it is a pointer type, the operation is performed following the rules for pointer arithmetic in C++. </para></description><returns><para>New value of the variable</para></returns></method><method name="operator--" cv=""><type>Type</type><parameter name=""><paramtype>int</paramtype></parameter><purpose>Atomically subtract and return old value. </purpose><description><para>
The same as <computeroutput>fetch_sub(1, memory_order_seq_cst)</computeroutput>. Avoid using the implicit increment operator, use fetch_sub with an explicit memory ordering constraint.</para><para>This method is available only if <computeroutput>Type</computeroutput> is an integral type or a non-void pointer type. If it is a pointer type, the operation is performed following the rules for pointer arithmetic in C++. </para></description><returns><para>Old value of the variable</para></returns></method></method-group><constructor><purpose>Create uninitialized atomic variable Creates an atomic variable. Its initial value is undefined. </purpose></constructor><constructor><parameter name="value"><paramtype>Type</paramtype><description><para>Initial value Creates and initializes an atomic variable. </para></description></parameter><purpose>Create an initialize atomic variable. </purpose><description><para>
</para></description></constructor><copy-assignment><parameter name="v"><paramtype>Type</paramtype></parameter><purpose>Implicit store. </purpose><description><para>

The same as <computeroutput>store(value, memory_order_seq_cst)</computeroutput>. Avoid using the implicit conversion operator, use store with an explicit memory ordering constraint. </para></description><returns><para>Copy of <computeroutput>value</computeroutput> </para></returns></copy-assignment><method-group name="private member functions"/><constructor><parameter name=""><paramtype>const <classname>atomic</classname> &amp;</paramtype></parameter><purpose>Deleted copy constructor. </purpose></constructor><copy-assignment><parameter name=""><paramtype>const <classname>atomic</classname> &amp;</paramtype></parameter><purpose>Deleted copy assignment. </purpose></copy-assignment></class><enum name="memory_order"><enumvalue name="memory_order_relaxed"><purpose>No constraint Atomic operation and other memory operations may be reordered freely. </purpose></enumvalue><enumvalue name="memory_order_consume"><purpose>Data dependence constraint Atomic operation must strictly precede any memory operation that computationally depends on the outcome of the atomic operation. </purpose></enumvalue><enumvalue name="memory_order_acquire"><purpose>Acquire memory Atomic operation must strictly precede all memory operations that follow in program order. </purpose></enumvalue><enumvalue name="memory_order_release"><purpose>Release memory Atomic operation must strictly follow all memory operations that precede in program order. </purpose></enumvalue><enumvalue name="memory_order_acq_rel"><purpose>Acquire and release memory Combines the effects of memory_order_acquire and memory_order_release. </purpose></enumvalue><enumvalue name="memory_order_seq_cst"><purpose>Sequentially consistent Produces the same result memory_order_acq_rel, but additionally enforces globally sequential consistent execution. </purpose></enumvalue><purpose>Memory ordering constraints. </purpose><description><para>This defines the relative order of one atomic operation and other memory operations (loads, stores, other atomic operations) executed by the same thread.</para><para>The order of operations specified by the programmer in the source code ("program order") does not necessarily match the order in which they are actually executed on the target system: Both compiler as well as processor may reorder operations quite arbitrarily. <emphasis role="bold">Specifying the wrong ordering constraint will therefore generally result in an incorrect program.</emphasis> </para></description></enum><function name="atomic_thread_fence"><type>void</type><parameter name="order"><paramtype>memory_order</paramtype><description><para>Memory ordering constraint</para></description></parameter><purpose>Insert explicit fence. </purpose><description><para>
Inserts an explicit fence. The exact semantic depends on the type of fence inserted:</para><para><itemizedlist>
<listitem><para><computeroutput>memory_order_relaxed:</computeroutput> No operation</para></listitem><listitem><para><computeroutput>memory_order_release:</computeroutput> Performs a "release" operation</para></listitem><listitem><para><computeroutput>memory_order_acquire</computeroutput> or <computeroutput>memory_order_consume:</computeroutput> Performs an "acquire" operation</para></listitem><listitem><para><computeroutput>memory_order_acq_rel:</computeroutput> Performs both an "acquire" and a "release" operation</para></listitem><listitem><para><computeroutput>memory_order_seq_cst:</computeroutput> Performs both an "acquire" and a "release" operation and in addition there exists a global total order of all <computeroutput>memory_order_seq_cst</computeroutput> operations </para></listitem></itemizedlist>
</para></description></function></namespace></header></library-reference>
