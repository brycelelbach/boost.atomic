<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Class template atomic</title>
<link rel="stylesheet" href="../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.0">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Atomic">
<link rel="up" href="../atomic/reference.html#header.boost.libs.atomic.doc.atomic_hpp" title="Header &lt;boost/libs/atomic/doc/atomic.hpp&gt;">
<link rel="prev" href="../atomic/reference.html" title="Reference">
<link rel="next" href="memory_order.html" title="Type memory_order">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../atomic/reference.html"><img src="../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../atomic/reference.html#header.boost.libs.atomic.doc.atomic_hpp"><img src="../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="memory_order.html"><img src="../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="refentry" title="Class template atomic">
<a name="boost.atomic"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template atomic</span></h2>
<p>boost::atomic &#8212; Atomic datatype. </p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="emphasis"><em>// In header: &lt;<a class="link" href="../atomic/reference.html#header.boost.libs.atomic.doc.atomic_hpp" title="Header &lt;boost/libs/atomic/doc/atomic.hpp&gt;">boost/libs/atomic/doc/atomic.hpp</a>&gt;

</em></span><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Type&gt; 
<span class="bold"><strong>class</strong></span> <a class="link" href="atomic.html" title="Class template atomic">atomic</a> {
<span class="bold"><strong>public</strong></span>:
  <span class="emphasis"><em>// <a class="link" href="atomic.html#boost.atomicconstruct-copy-destruct">construct/copy/destruct</a></em></span>
  <a class="link" href="atomic.html#id340434-bb">atomic</a>();
  <a class="link" href="atomic.html#id340438-bb">atomic</a>(Type);
  <a class="link" href="atomic.html#id340480-bb">atomic</a>(<span class="bold"><strong>const</strong></span> <a class="link" href="atomic.html" title="Class template atomic">atomic</a> &amp;);
  atomic&amp; <a class="link" href="atomic.html#id340455-bb"><span class="bold"><strong>operator</strong></span>=</a>(Type);
  atomic&amp; <a class="link" href="atomic.html#id340492-bb"><span class="bold"><strong>operator</strong></span>=</a>(<span class="bold"><strong>const</strong></span> <a class="link" href="atomic.html" title="Class template atomic">atomic</a> &amp;);

  <span class="emphasis"><em>// <a class="link" href="atomic.html#id339398-bb">public member functions</a></em></span>
  <span class="type">Type</span> <a class="link" href="atomic.html#id339400-bb">load</a>(memory_order = memory_order_seq_cst) <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="atomic.html#id339454-bb">store</a>(Type, memory_order = memory_order_seq_cst) ;
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="atomic.html#id339507-bb">compare_exchange_weak</a>(Type &amp;, Type, 
                             memory_order = memory_order_seq_cst) ;
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="atomic.html#id339620-bb">compare_exchange_weak</a>(Type &amp;, Type, memory_order, memory_order) ;
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="atomic.html#id339687-bb">compare_exchange_strong</a>(Type &amp;, Type, 
                               memory_order = memory_order_seq_cst) ;
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="atomic.html#id339800-bb">compare_exchange_strong</a>(Type &amp;, Type, memory_order, memory_order) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id339867-bb">exchange</a>(Type, memory_order = memory_order_seq_cst) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id339902-bb">fetch_add</a>(Type, memory_order = memory_order_seq_cst) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id339936-bb">fetch_sub</a>(Type, memory_order = memory_order_seq_cst) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id339984-bb">fetch_and</a>(Type, memory_order = memory_order_seq_cst) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id340032-bb">fetch_or</a>(Type, memory_order = memory_order_seq_cst) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id340073-bb">fetch_xor</a>(Type, memory_order = memory_order_seq_cst) ;
  <a class="link" href="atomic.html#id340114-bb"><span class="bold"><strong>operator</strong></span> Type</a>(<span class="bold"><strong>void</strong></span>) <span class="bold"><strong>const</strong></span>;
  <span class="type">Type</span> <a class="link" href="atomic.html#id340138-bb"><span class="bold"><strong>operator</strong></span>&amp;=</a>(Type) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id340166-bb"><span class="bold"><strong>operator</strong></span>|=</a>(Type) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id340199-bb"><span class="bold"><strong>operator</strong></span>^=</a>(Type) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id340233-bb"><span class="bold"><strong>operator</strong></span>+=</a>(Type) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id340274-bb"><span class="bold"><strong>operator</strong></span>-=</a>(Type) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id340314-bb"><span class="bold"><strong>operator</strong></span>++</a>(<span class="bold"><strong>void</strong></span>) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id340344-bb"><span class="bold"><strong>operator</strong></span>++</a>(<span class="bold"><strong>int</strong></span>) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id340374-bb"><span class="bold"><strong>operator</strong></span>--</a>(<span class="bold"><strong>void</strong></span>) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id340404-bb"><span class="bold"><strong>operator</strong></span>--</a>(<span class="bold"><strong>int</strong></span>) ;
};</pre></div>
<div class="refsect1" title="Description">
<a name="id622802"></a><h2>Description</h2>
<p>An atomic variable. Provides methods to modify this variable atomically. Valid template parameters are:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>integral data types (char, short, int, ...)</p></li>
<li class="listitem"><p>pointer data types</p></li>
<li class="listitem"><p>any other data type that has a non-throwing default constructor and that can be copied via <code class="computeroutput">memcpy</code></p></li>
</ul></div>
<p>
</p>
<p>Unless specified otherwise, any memory ordering constraint can be used with any of the atomic operations. </p>
<div class="refsect2" title="atomic public construct/copy/destruct">
<a name="id622830"></a><h3>
<a name="boost.atomicconstruct-copy-destruct"></a><code class="computeroutput">atomic</code> 
        public
       construct/copy/destruct</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><a name="id340434-bb"></a>atomic();</pre>Create uninitialized atomic variable Creates an atomic variable. Its initial value is undefined. </li>
<li class="listitem">
<pre class="literallayout"><a name="id340438-bb"></a>atomic(Type value);</pre>Create an initialize atomic variable. <p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><code class="computeroutput">value</code></span></p></td>
<td><p>Initial value Creates and initializes an atomic variable. </p></td>
</tr></tbody>
</table></div></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id340480-bb"></a>atomic(<span class="bold"><strong>const</strong></span> <a class="link" href="atomic.html" title="Class template atomic">atomic</a> &amp;);</pre>Deleted copy constructor. </li>
<li class="listitem">
<pre class="literallayout">atomic&amp; <a name="id340455-bb"></a><span class="bold"><strong>operator</strong></span>=(Type v);</pre>Implicit store. <p>

The same as <code class="computeroutput">store(value, memory_order_seq_cst)</code>. Avoid using the implicit conversion operator, use store with an explicit memory ordering constraint. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Copy of <code class="computeroutput">value</code> </p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout">atomic&amp; <a name="id340492-bb"></a><span class="bold"><strong>operator</strong></span>=(<span class="bold"><strong>const</strong></span> <a class="link" href="atomic.html" title="Class template atomic">atomic</a> &amp;);</pre>Deleted copy assignment. </li>
</ol></div>
</div>
<div class="refsect2" title="atomic public member functions">
<a name="id622974"></a><h3>
<a name="id339398-bb"></a><code class="computeroutput">atomic</code> public member functions</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><span class="type">Type</span> <a name="id339400-bb"></a>load(memory_order order = memory_order_seq_cst) <span class="bold"><strong>const</strong></span>;</pre>Read the current value of the atomic variable. <p>

Valid memory ordering constraints are:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p><code class="computeroutput">memory_order_relaxed</code> </p></li>
<li class="listitem"><p><code class="computeroutput">memory_order_consume</code> </p></li>
<li class="listitem"><p><code class="computeroutput">memory_order_acquire</code> </p></li>
<li class="listitem"><p><code class="computeroutput">memory_order_seq_cst</code> </p></li>
</ul></div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see memory_order </p></td>
</tr></tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Current value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id339454-bb"></a>store(Type value, memory_order order = memory_order_seq_cst) ;</pre>Write new value to atomic variable. <p>
Valid memory ordering constraints are:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p><code class="computeroutput">memory_order_relaxed</code> </p></li>
<li class="listitem"><p><code class="computeroutput">memory_order_release</code> </p></li>
<li class="listitem"><p><code class="computeroutput">memory_order_seq_cst</code> </p></li>
</ul></div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see memory_order</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">value</code></span></p></td>
<td><p>New value </p></td>
</tr>
</tbody>
</table></div></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id339507-bb"></a>compare_exchange_weak(Type &amp; expected, Type desired, 
                           memory_order order = memory_order_seq_cst) ;</pre>Atomically compare and exchange variable. <p>

Atomically performs the following operation</p>
<pre class="programlisting">                if (variable==expected) {
                        variable=desired;
                        return true;
                } else {
                        expected=variable;
                        return false;
                }
</pre>
<p>This operation may fail "spuriously", i.e. the state of the variable is unchanged even though the expected value was found (this is the case on architectures using "load-linked"/"store conditional" to implement the operation).</p>
<p>The established memory order will be <code class="computeroutput">order</code> if the operation is successful. If the operation is unsuccesful, the memory order will be</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p><code class="computeroutput">memory_order_relaxed</code> if <code class="computeroutput">order</code> is <code class="computeroutput">memory_order_acquire</code> , <code class="computeroutput">memory_order_relaxed</code> or <code class="computeroutput">memory_order_consume</code> </p></li>
<li class="listitem"><p><code class="computeroutput">memory_order_release</code> if <code class="computeroutput">order</code> is <code class="computeroutput">memory_order_acq_release</code> or <code class="computeroutput">memory_order_release</code> </p></li>
<li class="listitem"><p><code class="computeroutput">memory_order_seq_cst</code> if <code class="computeroutput">order</code> is <code class="computeroutput">memory_order_seq_cst</code> </p></li>
</ul></div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">desired</code></span></p></td>
<td><p>Desired new value </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">expected</code></span></p></td>
<td><p>Expected old value </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see memory_order </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p><code class="computeroutput">true</code> if value was changed</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id339620-bb"></a>compare_exchange_weak(Type &amp; expected, Type desired, 
                           memory_order success_order, 
                           memory_order failure_order) ;</pre>Atomically compare and exchange variable. <p>

Atomically performs the following operation</p>
<pre class="programlisting">                if (variable==expected) {
                        variable=desired;
                        return true;
                } else {
                        expected=variable;
                        return false;
                }
</pre>
<p>This operation may fail "spuriously", i.e. the state of the variable is unchanged even though the expected value was found (this is the case on architectures using "load-linked"/"store conditional" to implement the operation).</p>
<p>The constraint imposed by <code class="computeroutput">success_order</code> may not be weaker than the constraint imposed by <code class="computeroutput">failure_order</code>. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">desired</code></span></p></td>
<td><p>Desired new value </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">expected</code></span></p></td>
<td><p>Expected old value </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">failure_order</code></span></p></td>
<td><p>Memory ordering constraint if operation is unsuccesful </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">success_order</code></span></p></td>
<td><p>Memory ordering constraint if operation is successful </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p><code class="computeroutput">true</code> if value was changed</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id339687-bb"></a>compare_exchange_strong(Type &amp; expected, Type desired, 
                             memory_order order = memory_order_seq_cst) ;</pre>Atomically compare and exchange variable. <p>

Atomically performs the following operation</p>
<pre class="programlisting">                if (variable==expected) {
                        variable=desired;
                        return true;
                } else {
                        expected=variable;
                        return false;
                }
</pre>
<p>In contrast to compare_exchange_weak, this operation will never fail spuriously. Since compare-and-swap must generally be retried in a loop, implementors are advised to prefer compare_exchange_weak where feasible.</p>
<p>The established memory order will be <code class="computeroutput">order</code> if the operation is successful. If the operation is unsuccesful, the memory order will be</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p><code class="computeroutput">memory_order_relaxed</code> if <code class="computeroutput">order</code> is <code class="computeroutput">memory_order_acquire</code> , <code class="computeroutput">memory_order_relaxed</code> or <code class="computeroutput">memory_order_consume</code> </p></li>
<li class="listitem"><p><code class="computeroutput">memory_order_release</code> if <code class="computeroutput">order</code> is <code class="computeroutput">memory_order_acq_release</code> or <code class="computeroutput">memory_order_release</code> </p></li>
<li class="listitem"><p><code class="computeroutput">memory_order_seq_cst</code> if <code class="computeroutput">order</code> is <code class="computeroutput">memory_order_seq_cst</code> </p></li>
</ul></div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">desired</code></span></p></td>
<td><p>Desired new value </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">expected</code></span></p></td>
<td><p>Expected old value </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see memory_order </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p><code class="computeroutput">true</code> if value was changed</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id339800-bb"></a>compare_exchange_strong(Type &amp; expected, Type desired, 
                             memory_order success_order, 
                             memory_order failure_order) ;</pre>Atomically compare and exchange variable. <p>

Atomically performs the following operation</p>
<pre class="programlisting">                if (variable==expected) {
                        variable=desired;
                        return true;
                } else {
                        expected=variable;
                        return false;
                }
</pre>
<p>In contrast to compare_exchange_weak, this operation will never fail spuriously. Since compare-and-swap must generally be retried in a loop, implementors are advised to prefer compare_exchange_weak where feasible.</p>
<p>The constraint imposed by <code class="computeroutput">success_order</code> may not be weaker than the constraint imposed by <code class="computeroutput">failure_order</code>. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">desired</code></span></p></td>
<td><p>Desired new value </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">expected</code></span></p></td>
<td><p>Expected old value </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">failure_order</code></span></p></td>
<td><p>Memory ordering constraint if operation is unsuccesful </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">success_order</code></span></p></td>
<td><p>Memory ordering constraint if operation is successful </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p><code class="computeroutput">true</code> if value was changed</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">Type</span> <a name="id339867-bb"></a>exchange(Type value, memory_order order = memory_order_seq_cst) ;</pre>Atomically exchange variable. <p>

Atomically exchanges the value of the variable with the new value and returns its old value. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see memory_order </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">value</code></span></p></td>
<td><p>New value </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Old value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">Type</span> <a name="id339902-bb"></a>fetch_add(Type operand, memory_order order = memory_order_seq_cst) ;</pre>Atomically add and return old value. <p>

Atomically adds operand to the variable and returns its old value. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see memory_order </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Old value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">Type</span> <a name="id339936-bb"></a>fetch_sub(Type operand, memory_order order = memory_order_seq_cst) ;</pre>Atomically subtract and return old value. <p>

Atomically subtracts operand from the variable and returns its old value.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type or a non-void pointer type. If it is a pointer type, <code class="computeroutput">operand</code> is of type <code class="computeroutput">ptrdiff_t</code> and the operation is performed following the rules for pointer arithmetic in C++. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see memory_order </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Old value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">Type</span> <a name="id339984-bb"></a>fetch_and(Type operand, memory_order order = memory_order_seq_cst) ;</pre>Atomically perform bitwise "AND" and return old value. <p>

Atomically performs bitwise "AND" with the variable and returns its old value.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type or a non-void pointer type. If it is a pointer type, <code class="computeroutput">operand</code> is of type <code class="computeroutput">ptrdiff_t</code> and the operation is performed following the rules for pointer arithmetic in C++. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see memory_order </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Old value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">Type</span> <a name="id340032-bb"></a>fetch_or(Type operand, memory_order order = memory_order_seq_cst) ;</pre>Atomically perform bitwise "OR" and return old value. <p>

Atomically performs bitwise "OR" with the variable and returns its old value.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see memory_order </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Old value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">Type</span> <a name="id340073-bb"></a>fetch_xor(Type operand, memory_order order = memory_order_seq_cst) ;</pre>Atomically perform bitwise "XOR" and return old value. <p>

Atomically performs bitwise "XOR" with the variable and returns its old value.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see memory_order </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Old value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id340114-bb"></a><span class="bold"><strong>operator</strong></span> Type(<span class="bold"><strong>void</strong></span>) <span class="bold"><strong>const</strong></span>;</pre>Implicit load. <p>
The same as <code class="computeroutput">load(memory_order_seq_cst)</code>. Avoid using the implicit conversion operator, use load with an explicit memory ordering constraint. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Current value of the variable</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">Type</span> <a name="id340138-bb"></a><span class="bold"><strong>operator</strong></span>&amp;=(Type operand) ;</pre>Atomically perform bitwise "AND" and return new value. <p>

The same as <code class="computeroutput">fetch_and(operand, memory_order_seq_cst)&amp;operand</code>. Avoid using the implicit bitwise "AND" operator, use fetch_and with an explicit memory ordering constraint. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr></tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>New value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">Type</span> <a name="id340166-bb"></a><span class="bold"><strong>operator</strong></span>|=(Type operand) ;</pre>Atomically perform bitwise "OR" and return new value. <p>

The same as <code class="computeroutput">fetch_or(operand, memory_order_seq_cst)|operand</code>. Avoid using the implicit bitwise "OR" operator, use fetch_or with an explicit memory ordering constraint.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr></tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>New value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">Type</span> <a name="id340199-bb"></a><span class="bold"><strong>operator</strong></span>^=(Type operand) ;</pre>Atomically perform bitwise "XOR" and return new value. <p>

The same as <code class="computeroutput">fetch_xor(operand, memory_order_seq_cst)^operand</code>. Avoid using the implicit bitwise "XOR" operator, use fetch_xor with an explicit memory ordering constraint.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr></tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>New value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">Type</span> <a name="id340233-bb"></a><span class="bold"><strong>operator</strong></span>+=(Type operand) ;</pre>Atomically add and return new value. <p>

The same as <code class="computeroutput">fetch_add(operand, memory_order_seq_cst)+operand</code>. Avoid using the implicit add operator, use fetch_add with an explicit memory ordering constraint.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type or a non-void pointer type. If it is a pointer type, <code class="computeroutput">operand</code> is of type <code class="computeroutput">ptrdiff_t</code> and the operation is performed following the rules for pointer arithmetic in C++. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr></tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>New value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">Type</span> <a name="id340274-bb"></a><span class="bold"><strong>operator</strong></span>-=(Type operand) ;</pre>Atomically subtract and return new value. <p>

The same as <code class="computeroutput">fetch_sub(operand, memory_order_seq_cst)-operand</code>. Avoid using the implicit subtract operator, use fetch_sub with an explicit memory ordering constraint.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type or a non-void pointer type. If it is a pointer type, <code class="computeroutput">operand</code> is of type <code class="computeroutput">ptrdiff_t</code> and the operation is performed following the rules for pointer arithmetic in C++. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr></tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>New value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">Type</span> <a name="id340314-bb"></a><span class="bold"><strong>operator</strong></span>++(<span class="bold"><strong>void</strong></span>) ;</pre>Atomically increment and return new value. <p>
The same as <code class="computeroutput">fetch_add(1, memory_order_seq_cst)+1</code>. Avoid using the implicit increment operator, use fetch_add with an explicit memory ordering constraint.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type or a non-void pointer type. If it is a pointer type, the operation is performed following the rules for pointer arithmetic in C++. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>New value of the variable</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">Type</span> <a name="id340344-bb"></a><span class="bold"><strong>operator</strong></span>++(<span class="bold"><strong>int</strong></span>) ;</pre>Atomically increment and return old value. <p>
The same as <code class="computeroutput">fetch_add(1, memory_order_seq_cst)</code>. Avoid using the implicit increment operator, use fetch_add with an explicit memory ordering constraint.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type or a non-void pointer type. If it is a pointer type, the operation is performed following the rules for pointer arithmetic in C++. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Old value of the variable</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">Type</span> <a name="id340374-bb"></a><span class="bold"><strong>operator</strong></span>--(<span class="bold"><strong>void</strong></span>) ;</pre>Atomically subtract and return new value. <p>
The same as <code class="computeroutput">fetch_sub(1, memory_order_seq_cst)-1</code>. Avoid using the implicit increment operator, use fetch_sub with an explicit memory ordering constraint.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type or a non-void pointer type. If it is a pointer type, the operation is performed following the rules for pointer arithmetic in C++. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>New value of the variable</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="type">Type</span> <a name="id340404-bb"></a><span class="bold"><strong>operator</strong></span>--(<span class="bold"><strong>int</strong></span>) ;</pre>Atomically subtract and return old value. <p>
The same as <code class="computeroutput">fetch_sub(1, memory_order_seq_cst)</code>. Avoid using the implicit increment operator, use fetch_sub with an explicit memory ordering constraint.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type or a non-void pointer type. If it is a pointer type, the operation is performed following the rules for pointer arithmetic in C++. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Old value of the variable</p></td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2009 Helge Bahmann<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../atomic/reference.html"><img src="../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../atomic/reference.html#header.boost.libs.atomic.doc.atomic_hpp"><img src="../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="memory_order.html"><img src="../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
